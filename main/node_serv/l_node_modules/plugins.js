var child_process=require('child_process')
var fs=require('fs');
var path=require('path');
let execSync=child_process.execSync; // synchronouse shell run : var result=execSync(cmdStr)
let existsSync=fs.existsSync;
let lstatSync=fs.lstatSync;
let readdirSync=fs.readdirSync;

$cn=require("./libNative").libNative

let main={
    init : (params)=>{
        //console.log("plugins init : ");
        let pwd=path.resolve( "./" );         
        let main_path=path.resolve( "../" );         

        //console.log("pwd" , main_path)
        let plugins_path=path.resolve( "../setup/packages/all" );
        let plugins_path_cust=path.resolve( "../setup/packages/all_custom" );


        
        
        let allPluginRecs=[];
        
        let proc=(rec)=>{
            //  cb({ data : jsn , file  : files[i] ,pathFile : f, pathDir  : f0 , dir : files0[i0]  })
            //console.log("plugin : ", rec);
            if (rec){
                if (rec.data){


                    let nr={};

                    console.log("plugin : ", rec.data.name + " - " +  "v" + rec.data.version);

                    nr.name=rec.data.name;
                    nr.data=rec.data;

                    allPluginRecs.push(nr);

                }
            }
        }

        walkPlugins(plugins_path ,proc);
        walkPlugins(plugins_path_cust ,proc);

        return allPluginRecs;

    },
    auto_run : function(){ 
        //console.log("auto_running plugins" )
    },
    run_after_init : function(params){

    },
    __app : [ // must be named __app to create a route
        {   
            name  : "plugins",
            route : "/plugins", // if route not included it will defualt to to name
            type : "get", // get or post
            cb : function(req, res, corestuff){ // or fn or callback that will run once route is called , // corestuff ,gives you some extra modules , parameters and values to use  // eg : { app : app,express : express,mds :mds , mdsfn : mdsfn , vserv : $vserv, pub : pub ,debug_0 ,http : http , io : io}
                let tmp="";
                for (let p in  corestuff.mds ){
                    
                    
                    //tmp= tmp + " , " + p ;

                }
                res.send("" + tmp);
                //res.send("testing test3 " + tmp);
            } 


        }, // add as many routes as you want in this array, and change name and route string values to your liking
        {   
            name  : "plugins",
            route : "/plugins", // if route not included it will defualt to to name
            type : "post", // get or post
            cb : async function(req, res, corestuff){ // or fn or callback 
                var bd=req.body // get data sent from front end


                let userAuthCustom=(i1,cb1)=>{
                            // l1 --> allowed , userid , status                            
                            let group

                            if (i1.allowed){
                                corestuff.mds.vrtw.gdb.users.getUser({ userid : i1.userid },(dt)=>{
                                    //console.log(dt)

                                    if (dt.group===undefined){
                                        group="guest"                            
                                    }else{
                                        group=dt.group
                                    }

                                    if (dt.group==="users"){
                                        group=dt.group
                                    } 
                                    if (dt.group==="admin"){
                                        group=dt.group
                                    }

                                    let other={}
                                    other.group=group

                                    if (dt.group==="admin"){
                                        
                                    }else{

                                    }
                                    //cb1({ allowed : false})
                                    cb1({ other : other})
                                })
                            }                            
                        }

                        corestuff.mds.vrtw.login.verifyLoginAPI({ req : req , userAuthCust : userAuthCustom},function(vd){
                                        
                            let allowedC={}
                            allowedC.check=true;
                            allowedC.allowed=false;
                            allowedC.vd=vd;
                            allowedC.allowedUsers=["admin"];
                            allowedC.allowedUsersCheck=true;
                            allowedC.allowedGroups=["admin"];
                            allowedC.allowedGroupsCheck=true;
                            allowedC.allowedSuccessMsg=""

                            



                            switch(bd.type) {
                                case "listAll":
                                    if (allowedCheckUserAndGroupFn(allowedC)===false){
                                        console.log(new Date(), allowedC.allowedSuccessMsg);
                                        res.jsonp({ data : { all : []} , status : "failed"  ,bStatus : false, error : allowedC.allowedSuccessMsg + "...user does have permmision to run this request, request access from service admins"});
                                        return
                                    }          

                                    if (true){
                                        let allPluginRecs=listAll();                                    


                                        res.jsonp({ data : { all : allPluginRecs,} , status : "success" ,bStatus : true, err : ""});     
                                    
                                        return ;
                                    }
                                break;

                                case "listInstalled":
                                    if (allowedCheckUserAndGroupFn(allowedC)===false){
                                        console.log(new Date(), allowedC.allowedSuccessMsg);
                                        res.jsonp({ data : { all : []} , status : "failed"  ,bStatus : false, error : allowedC.allowedSuccessMsg + "...user does have permmision to run this request, request access from service admins"});
                                        return
                                    }          
                                    if (true){
                                
                                        let allPluginRecs=listAll();     

                                        let retData=[]


                                        let src_not_exists=[]
                                        let dst_not_exists=[]

                                        // let total_path=prec.files.length;

                                        let allpackages=[]

                                        allPluginRecs.forEach((r,i)=>{
                                            let nrec={
                                                installed : true,
                                                paths_not_installed : [],

                                                version_installed : 0,
                                                version_package : 0,
                                            }

                                            let prec=parsePluginConf(r);
                                            //console.log("nr : ", nr );

                                            nrec.code=prec.code;
                                            nrec.name=prec.name;
                                            nrec.paths_total=prec.files.length;
                                            nrec.paths_exist=0;

                                            nrec.version_package=prec.version;
                                            
                                            

                                            if (prec.files){                                                
                                                prec.files.forEach((r2,i2)=>{
                                                    let is_version=false;
                                                    if (r2.type){
                                                        if (r2.type==="version"){
                                                            is_version=true;                                                            
                                                        }
                                                    }
                                                    if (r2.src){
                                                        //console.log("src", r2.src);
                                                    }
                                                    if (r2.dst){
                                                        //console.log("dest", r2.dst);
                                                        if (existsSync(r2.dst)===false){
                                                            let tmp_rec={
                                                                plugin : prec.name,
                                                                name : r2.name,
                                                                path : r2.dst,
                                                            };
                                                            dst_not_exists.push(tmp_rec);
                                                            nrec.paths_not_installed.push(tmp_rec);

                                                            nrec.installed=false;                                                        
                                                        }else{
                                                            nrec.paths_exist++;

                                                            if (is_version){
                                                                let ftxt=fs.readFileSync(r2.dst,"utf8")
                                                                let jsn=JSON.parse(ftxt);
                                                                nrec.version_installed=jsn.version;
                                                                //console.log("\n\nversion...", jsn.version );
                                                            }
                                                            
                                                        }
                                                    }
                                                })

                                            }

                                            allpackages.push(nrec);

                                        });


                                        //if (dst_not_exists.length > 1){
                                        //    dst_not_exists.forEach((r,i)=>{                                                
                                        //        console.log("not installed on local path", JSON.stringify(r) );
                                        //        
                                        //    });
                                        //    
                                        //}
                                        // total_path 

                                        //console.log(JSON.stringify( allpackages,null,2));
                                        
                                        res.jsonp({ data : {  installed : allpackages, all : allPluginRecs} , status : "success" ,bStatus : true, err : ""});     

                                        return ;
                                    }
                                break


                                case "install":
                                    if (allowedCheckUserAndGroupFn(allowedC)===false){
                                        console.log(new Date(), allowedC.allowedSuccessMsg);
                                        res.jsonp({ data : { all : []} , status : "failed"  ,bStatus : false, error : allowedC.allowedSuccessMsg + "...user does have permmision to run this request, request access from service admins"});
                                        return
                                    }          
                                    if (true){
                                
                                        let allPluginRecs=listAll();     

                                        let retData=[]
                                        allPluginRecs.forEach(()=>{


                                        });

                                        
                                        
                                        res.jsonp({ data : {  installed : retData, all : allPluginRecs} , status : "success" ,bStatus : true, err : ""});     

                                        return ;
                                    }
                                break

                                case "remove":
                                    if (allowedCheckUserAndGroupFn(allowedC)===false){
                                        console.log(new Date(), allowedC.allowedSuccessMsg);
                                        res.jsonp({ data : { all : []} , status : "failed"  ,bStatus : false, error : allowedC.allowedSuccessMsg + "...user does have permmision to run this request, request access from service admins"});
                                        return
                                    }          
                                    if (true){
                                
                                        let allPluginRecs=listAll();     

                                        let retData=[]
                                        allPluginRecs.forEach(()=>{


                                        });

                                        
                                        
                                        res.jsonp({ data : {  installed : retData, all : allPluginRecs} , status : "success" ,bStatus : true, err : ""});     

                                        return ;
                                    }
                                break

                                case "archive":
                                    if (allowedCheckUserAndGroupFn(allowedC)===false){
                                        console.log(new Date(), allowedC.allowedSuccessMsg);
                                        res.jsonp({ data : { all : []} , status : "failed"  ,bStatus : false, error : allowedC.allowedSuccessMsg + "...user does have permmision to run this request, request access from service admins"});
                                        return
                                    }          
                                    if (true){
                                
                                        let allPluginRecs=listAll();     

                                        let retData=[]
                                        allPluginRecs.forEach(()=>{


                                        });

                                        
                                        
                                        res.jsonp({ data : {  installed : retData, all : allPluginRecs} , status : "success" ,bStatus : true, err : ""});     

                                        return ;
                                    }
                                break

                                default:
                            }


                            res.jsonp({ status : "apiPluginsError" ,bStatus : true})
                        
                            return
                        })

            } 


        },
    ],
}


let allowedCheckUserAndGroupFn=(allowedC)=>{
    let vd=allowedC.vd
    if (allowedC.check){ // validation
        if (vd.allowed ){                                         
            if (allowedC.allowed===false){
                if (allowedC.allowedGroupsCheck){
                    if (vd.other){ // group allowed
                        if (vd.other.group){
                            allowedC.allowedGroups.forEach((r,i)=>{
                                if (vd.other.group===r){
                                    allowedC.allowed=true;
                                    allowedC.allowedSuccessMsg=`group ${vd.other.group} is allowed\n`;
                                }
                            })

                        }
                    }
                }
                if (allowedC.allowed===false){
                    allowedC.llowedSuccessMsg=`group ${vd.other.group} is not allowed\n`;
                }
            }
            if (allowedC.allowed===false){ // userid allowed
                if (allowedC.allowedUsersCheck){
                    allowedC.allowedUsers.forEach((r,i)=>{
                        if (vd.userid===r){
                            allowedC.allowed=true;
                        }
                    })
                    if (allowedC.allowed===false){
                        allowedC.allowedSuccessMsg+=`user ${vd.other.group} is not allowed\n`;
                    }
                }
            }
            
        }
        if (allowedC.allowed===false){
            return false
        }
        return true
    }
}

let walkPlugins=(fpath, cb)=>{
    let stat0=fs.lstatSync(fpath);
    if (stat0.isDirectory()) {
        let files0=fs.readdirSync(fpath);
        let f0, l0 = files0.length; // file , file count
        for (let i0 = 0; i0 < l0; i0++) {   
            f0 = path.join(fpath, files0[i0]);
            
            //console.log("filename0 : " ,f0);

            let stat=fs.lstatSync(f0);
            if (stat.isDirectory()) {
                let files=fs.readdirSync(f0);
                let f, l = files.length; // file , file count
                for (let i = 0; i < l; i++) {   
                    f = path.join(f0, files[i]);
                    let stat=fs.lstatSync(f);
                    if (stat.isFile()) {     
                        if (files[i]==="plugin.json"){
                            if (typeof(cb)==="function"){
                                let ftxt=fs.readFileSync(f,"utf8")
                                let jsn=JSON.parse(ftxt);
                                cb({ data : jsn , file  : files[i] ,pathFile : f, pathDir  : f0 , dir : files0[i0]  })
                            }
                        }

                    }
                }

                
            }

        }

    }
}

let parsePluginConf=(rec)=>{
    let ret_rec={

        files : []

    }

    let name=rec.name; 
    ret_rec.name=name;
    let code=rec.data.code;
    ret_rec.code=code;
    let files=[]
    let data={}
    let base_main_path=""
    if (rec.data){
        
        data=rec.data;
        code=rec.data.code;

        ret_rec.version=data.version

        if (rec.data.files){
            if (rec.data.files.base_main_path){
                base_main_path=rec.data.files.base_main_path;
            }
            if (rec.data.files.all){
                files=rec.data.files.all
            }
        }
    

    }

    if (files){                                
        files.forEach((r2 , i2)=>{
                let src_path=base_main_path + r2.src;
                let dst_path=base_main_path + r2.dest;            

                let nr={
                    name : r2.name ,
                    src : src_path,
                    dst : dst_path,                    
                };

                if (r2.type){
                    nr.type=r2.type;
                }

                ret_rec.files.push(nr)
        });
    };


    return ret_rec;
}

let listAll=()=>{
    let pwd=path.resolve( "./" );         
    let main_path=path.resolve( "../" );         

    //console.log("pwd" , main_path)
    let plugins_path=path.resolve( "../setup/packages/all" );
    let plugins_path_cust=path.resolve( "../setup/packages/all_custom" );


    
    
    let allPluginRecs=[];
    
    let proc=(rec)=>{
        //  cb({ data : jsn , file  : files[i] ,pathFile : f, pathDir  : f0 , dir : files0[i0]  })
        //console.log("plugin : ", rec);
        if (rec){
            if (rec.data){


                let nr={};

                //console.log("plugin : ", rec.data.name + " - " +  "v" + rec.data.version);

                nr.name=rec.data.name;
                nr.data=rec.data;

                allPluginRecs.push(nr);

            }
        }
    }

    walkPlugins(plugins_path ,proc);
    walkPlugins(plugins_path_cust ,proc);

    return allPluginRecs;

}

module.exports.Plugins=main;